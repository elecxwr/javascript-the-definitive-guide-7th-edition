# 第1章: JavaScript简介

JavaScript是一门为Web网页而生的编程语言，基本上所有的网站都或多或少的使用了JavaScript这门语言，并且你现在使用的所有智能终端设备（PC电脑/平板/手机等），为了满足日常使用，基本都安装了网页浏览器，这些浏览器都内置了JavaScript的解释器；有了这些基础设备的支持，让JavaScript有了广泛的应用空间，也让JavaScript成为了目前世界上使用最广泛的编程语言，没有之一。除此以外，自从2009年Node.js的发布以后，让JavaScript拥有了脱离浏览器的运行能力，Node.js也深受广大开发者的喜爱，社区日益壮大，目前Node.js的生态已经很完善了；Node.js的成功也让JavaScript常用于后端开发。不过JavaScript本身也是一门令人诟病的语言，学习起来可能感觉很无厘头；但是这些都不是问题，无论你是从头开始学习的小白，还是对JavaScript理解不深入的开发者，这本书都会让你全面的掌握JavaScript这门语言。

如果你以前使用过其他面向对象语言，那么你在学习JavaScript的时候会事半功倍，也更容易理解JavaScript的原理。需要事先知道的是，JavaScript是一门弱类型语言，变量在声明的时候是无需指定类型的，变量的类型取决于后续给它赋予什么类型的值。如果你以前是使用Java或者C++等强类型语言，开始可能感觉没有规则，很不适应，但是别担心，你很快就会适应；如果你以前是没有任何基础的小白，也不需要忧虑，JavaScript很好学。

"JavaScript"的名字本身，可能会让你和Java产生误会；这是因为JavaScript创建之初，Java那会风头正盛，JavaScript创始人Brendan Eich为了蹭热度才起的这个名字，这在当时属于标题党。两者的关系类似"雷锋"和"雷峰塔"的关系，或者"老婆"和"老婆饼"的关系。目前JavaScript已经成为一种健壮高效的通用语言了，这些黑历史就没有必要深究了，我们学习技术才是硬道理。

<div style="border: 1px solid black; padding:10px; margin: 10px 0">
  <center><h2>JavaScript: 名字, 版本和模式<h2></center>
  <p>JavaScript 是 Netscape 创建的，至于历史演变没有什么好说的，这本书的使用的 ECMASctipt，是描述 JavaScript 这门语言的核心</p>
  <p>目前常说的JavaScript基础语法指的是2010年发布的第五版ECMASctipt，ECMASctipt简称ES，而ES5指的是第五版的ECMAScript，这本书基于ES5进行渐进式书写，自从2015年的ECMAScript 2015开始，ECMAScript每年都会发布一个release版本的规范，比如ECMASctipt 2016(ES6), ECMASctipt 2017(ES7)...</p>
  <p>虽然JavaScript早期的语法有很多缺陷，但是为了向后兼容，我们并不能粗暴的进行移除，为了解决这个问题，在ECMAScript2010这个版本开始引入严格模式的使用方式，详细可参考本书的第5.6.3节，那一节详细介绍了普通模式和严格模式的区别。从ES6开始，新的语法会隐式调用严格模式，比如你使用ES6的 class 创建类，则该类中的所有代码都自动使用严格模式进行解析，如果你在类的代码中使用以前有缺陷的语句，将不会被支持。本书会介绍以前老的JavaScript语法，但同时也会指出这些有缺陷的语句不能正常运行在严格模式中。</p>
</div>

为了满足日常使用，所有的语言都有自己的标准库及用于基本输入和输出的平台。JavaScript的核心部分定义了这本语言的使用规范以及处理数据的最小API，但是它并不包含输入和输出的功能。输入和输出工作交给了JavaScript的宿主环境进行处理。

最常见的JavaScript宿主环境就是我们使用的浏览器及Node.js；在浏览器中，用户对鼠标和键盘的操作可以转化为JavaScript的输入信息，浏览器还允许JavaScript基于这些输入信息发起Http请求或者别的输出操作，比如JavaScript可以借助HTML和CSS向用户的输出他的输入信息。

而Node.js可以让JavaScript拥有访问整个操作系统的权利，允许JavaScript程序读取和写入系统文件，通过网络发送和接受数据等等操作，Node.js可以轻松的实现一个WEB服务器，还可以通过写一些简单的代码来代替Shell脚本进行工作。

本书的大部分内容都是介绍JavaScript这门语言的本身，第11章介绍了JavaScript的标准库，第15章介绍了JavaScript的宿主环境浏览器，第16章介绍了JavaScript的宿主环境Node.js。

本书首先介绍了JavaScript的基础知识，然后在这些基础之上继续探讨了更高级的用法。阅读本章的时候，你可以根据自己的实际情况有选择的进行阅读。如果你已经是一名经验丰富的JavaScript程序员，阅读的时候跳过本章也是没有任何问题的，不过在跳过之前，推推荐你看一下本章的 `案例 1-1` 。

学习编程的时候，如果单纯的按照A, B, C, D, E这种顺序逐个学习，对掌握这们语言的帮助并不是很大，因为每一个模块都不是独立存在的，都会和其它模块相关联。所以本书在介绍某个模块时，会穿插必要的相关知识。

##  1.1 了解 JavaScript

当你跟着本书学习JavaScript时，请一定要动手试一下本书中的案例，然后进行修改，看它是不是按照你的预期进行工作，这么做可以加深你对JavaScript这门语言的理解（如果你能动手敲一遍本书中的案例，那就更好啦）。

为了能够正常的查看结果，你需要一个JavaScript的解释器。最简单的办法就是使用浏览器的开发者工具（使用 <kbd>F12</kbd>，<kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>i</kbd> 或者 <kbd>Command</kbd>+<kbd>Option</kbd>+<kbd>i</kbd> 进行打开），并选中其中的 `console` 选项卡。然后就可以输入JavaScript代码了，输入完毕敲回车键，就可以看到代码的输出结果了。开发者工具通常显示在浏览器窗口的底部或者右侧，你可以根据自己的使用习惯进行调整，你甚至可以把它和浏览器分离开，作为单独的窗口进行使用 (如 `图 1-1` 中的展示)。

<div style="border: 1px solid black; padding:10px; margin: 10px 0">
  <img src='./img/1-1.png'/>
</div>

<i>图 1-1. 火狐浏览器的开发人员工具中JavaScript控制台</i>

另一种方式是从 `https://nodejs.org` 下载Node.js，在系统成功安装Nodejs以后，你只需要在终端里输入 `node` ，回车后就就可以得到一个交互式JavaScript对话框，在这Nodejs里属于REPL模块，类似浏览器的控制台。

``` bash
$ node
Welcome to Node.js v12.13.0.
Type ".help" for more information.
> .help
.break    Sometimes you get stuck, this gets you out
.clear    Alias for .break
.editor   Enter editor mode
.exit     Exit the repl
.help     Print this help message
.load     Load JS from a file into the REPL session
.save     Save all evaluated commands in this REPL session to a file

Press ^C to abort current expression, ^D to exit the repl 
> let x = 2, y = 3;
undefined
> x+ y
5
> (x === 2) && (y === 3)
true
> (x > 3) || (y < 3)
false
```

## 1.2 Hello World

当你准备正式学习JavaScript的时候，使用浏览器的开发者工具或Node.js的REPL交互环境，就非常不合适了，推荐使用编辑器进行写代码。你可以把JavaScript代码写在 `.js` 文件中，然后使用Node.js运行这个 `.js` 文件（写完JavaScript之后，请确保你的 `.js` 文件已经被保存）。或者把写好的代码复制到浏览器控制台或者Node.js REPL交互环境中去运行也是可以的。

``` 
$ node snippet.js
```

如果你使用上面这种方式运行 `.js` 文件。它不会像 **浏览器的开发者工具** 或 **Node.js的REPL交互环境** 那样自动打印你每一行代码的返回值。如果你需要输出这些信息，你可以使用 **console.log()**来输出你想要查看的值。

比如，你创建一个包含下面代码的 `hello.js` 文件。

``` js
console.log("Hello World!");
```

使用 `node hello.js` 运行该文件，你会看到终端里打印了 "Hello World!" 这条消息。

**注意**：当你运行 `node hello.js` 时，请确保你终端所在的目录和编辑器中文件所在的目录是一致的，否则可能会出现下面报错

``` bash
internal/modules/cjs/loader.js:968
  throw err;
  ^

Error: Cannot find module 'E:\SystemUserDir\Desktop\hello.js'
    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:965:15)
    at Function.Module._load (internal/modules/cjs/loader.js:841:27)
    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:71:12)
    at internal/main/run_main_module.js:17:47 {
  code: 'MODULE_NOT_FOUND',
  requireStack: []
}
```

Windows电脑上终端的打开方式：

1. 打开 `hello.js` 文件所在的目录
2. 按住Shift键后，在文件夹内点击鼠标右键
3. 点击菜单的 **在此处打开命令窗口**

如果你想要在浏览器中查看输出的信息，请在同一目录下创建 `hello.html` , 并把下面的代码写在新建的html文件中。

``` html
<script src="hello.js"></script>
```

然后打开浏览器，在电脑文件夹中找到新创建的 `hello.html` 文件，把文件直接拖到浏览器内即可。 

浏览器的地址栏出现类似下面的网址。

``` 
file:///Users/username/javascript/hello.html
或
file:///E:/file/010/hello.html
```

打开浏览器的开发者工具，选择 `Console` 选项卡，就可以看到输出的"Hello World!" 这条消息。

这个例子的配套源码下载，请移步译者的Github仓库

<https://github.com/anbang/javascript-the-definitive-guide-7th-edition>

## 1.3 JavaScript之旅

这一节通过例子让你快速预览下后面第二章和第三章的主要内容。这些内容后面会深入的进行探讨。**第2章**介绍了JavaScript注释，分号和Unicode字符集等内容。**第三章**开始真正的进入JavaScript的学习，主要介绍了JavaScript变量，以及可以分配哪些类型的值给变量。

下面是一个实例代码，用来介绍第二章和第三章的主要内容；

``` js
// 双斜杠后面的所有内容都是注释内容。
// 仔细阅读注释: 他们的作用是解释 JavaScript 代码。

// 变量是数据的代言人。
// 可以使用 let 关键字声明变量:

let x;              // 声明一个名字叫 x 的变量

// 可以通过 = 把值分配给变量
x = 0;              // 现在变量 x 被赋予 0 这个值
x                   // => 0: 变量 x 已经是0了

// JavaScript 支持多种类型的值
x = 1;              // 数字类型
x = 0.01;           // 数字类型可以是整数，也可以是小数
x = "hello world";  // 字符串类型，使用引号进行包裹
x = 'JavaScript';   // 使用单引号进行包裹，也是一个合法的字符串类型

// 学初中英语中，判断题通常让写 T 或 F。
// 这里的 T 和 F 表示中文的对和错
// T 代表 true ， F 代表 false
// 布尔值是计算机科学中的逻辑数据类型，
// 表示某件事情是否正确，只有 true 和 false 两种可能
x = true;           // 一个布尔值
x = false;          // 另外一个布尔值。

x = null;           // Null 是一个特殊值，表示"没有值"
x = undefined;      // Undefined 是另外一个特殊值，有点像 null.
```

在第6章和第7章，会重点介绍JavaScript的两个非常重要的数据类型: 对象和数组。因为它们在JavaScript中的地位太重要了，在你没有读到那一章之前，你会经常看到它，所以这里也顺便介绍下对象和数组。

``` js
// 对象是JavaScript中最重要的数据类型。
// 对象一个 key/value 结构的集合。
// 它的产生可以直接创建出来，也可以由特定的字符串解析而来
let book = {                // 对象是用一对花括号括起来的值
    topic: "JavaScript",    // 属性 "topic" 拥有字符串 "JavaScript" 这个值
    edition: 7              // 属性 "edition" 拥有 数字 7 这个值
};                          // 记得对象是一对花括号，记得用 } 来结束

// 访问对象的熟悉，使用 . 或者 []:
book.topic                  // => "JavaScript"
book["edition"]             // => 7: 访问属性值的另一种方法

book.author = "Flanagan";   // 给对象创建新的属性
book.contents = {};         // {} 是没有属性值的空对象，但它也是合法的对象类型

// 使用可选链操作符 ?. 访问对象属性 
// ES2020的新语法，该语法于2020年8月3日进入规范的第四阶段
book.contents?.ch01?.sect1  // => undefined: book.contents 中没有 ch01 的属性

// JavaScript 还支持数组类型 (一个有序的元素序列) 
let primes = [2, 3, 5, 7];  // 拥有4个值的数组，使用 [ 和 ] 进行包裹
primes[0]                   // => 2: 数组的第一个元素 (注意：数组第一个元素的索引是 0 而不是 1 )
primes.length               // => 4: 查询这个数组当前有多少个元素
primes[primes.length - 1]   // => 7: 获取数组最后一个元素(因为索引是以0开始，而不是1)

primes[4] = 9;              // 给数组添加一个新元素
primes[4] = 11;             // 更改数组的原有元素

let empty = [];             // [] 是一个没有任何元素的空数组
empty.length                // => 0

// 数组和对象的内部，还可以拥有其他的数组和对象
let points = [              // 拥有2个元素的数组
    {
        x: 0,
        y: 0
    },                      // 每个元素都是一个对象
    {
        x: 1,
        y: 1
    }
];
let data = {                // 拥有两个属性的对象
    trial1: [
        [1, 2],
        [3, 4]
    ],                      // 每一个属性的值都是一个数组
    trial2: [
        [2, 3],
        [4, 5]
    ]                       // 数组内还包含了数组
};
```

<div style="border: 1px solid black; padding:10px; margin: 10px 0">
  <center><h2>示例代码中的注释<h2></center>
  <p>你可能已经在上面代码中看到了以箭头 <code>=> </code>开头的注释，箭头之后的值表示注释之前的代码结果。这是模拟浏览器中开发者工具的Console的交互结果</p>
  <p>另外 // => 这种注释也是作者用来做断言使用的，方法是编写一个工具用来测试代码并验证它的结果是否等于 // = 之后的值，作者通过这种方式可以大大减少这本书中的错误，这种断言的思路还是非常值得学习的。</p>
  <p>除了上面这种断言方式，作者还使用了下面两种断言方法，你在本书的后面会大量看到</p>
  <p>两种相关的，用来做断言的注释：</p>
  <ul>
    <li>如果你看到注释为 <code>// a == 42 </code>，则表示注释之前的代码运行之后，变量a的值为42。</li>
    <li>如果你看到 <code>// ! </code> 这种注释，则表示注释之前的行的代码会引起执行异常，而感叹号之后的其余注释，会说明引起这种异常的原因。</li>
  </ul>
</div>

上面代码中所示的，用来创建数组的 `[]` 符号 , 和创建对象中的 `{}` ,这些语法被称为初始化表达式；这些相关的内容会在第四章详细介绍。比如获取对象的属性和数组元素的`.`  和 `[]` ，这也是一个表达式。

除了上面的表达式以外，在JavaScript中，最常见语法还有运算符：（ TODO 注：这一句翻译的不好，后面仔细研究）

原文： One of the most common ways to form expressions in JavaScript is to use operators:

``` js
// Operators act on values (the operands) to produce a new value. 
// Arithmetic operators are some of the simplest:
3 + 2 // => 5: addition
3 - 2 // => 1: subtraction
3 * 2 // => 6: multiplication
3 / 2 // => 1.5: division
points[1].x - points[0].x // => 1: more complicated operands also work 
"3" + "2" // => "32": + adds numbers, concatenates strings

// JavaScript defines some shorthand arithmetic operators
let count = 0; // Define a variable
count ++; // Increment the variable
count --; // Decrement the variable
count += 2; // Add 2: same as count = count + 2;
count *= 3; // Multiply by 3: same as count = count * 3;
count // => 6: variable names are expressions, too.

// Equality and relational operators test whether two values are equal,
// unequal, less than, greater than, and so on. They evaluate to true or false.
let x = 2,
    y = 3; // These = signs are assignment, not equality tests
x === y // => false: equality
x !== y // => true: inequality
x < y // => true: less-than
x <= y // => true: less-than or equal
x > y // => false: greater-than
x >= y // => false: greater-than or equal
"two" === "three" // => false: the two strings are different
"two" > "three" // => true: "tw" is alphabetically greater than "th"
false === (x > y) // => true: false is equal to false

// Logical operators combine or invert boolean values
(x === 2) && (y === 3) // => true: both comparisons are true. && is AND
(x > 3) || (y < 3) // => false: neither comparison is true. || is OR
!(x === y) // => true: ! inverts a boolean value
```

If JavaScript expressions are like phrases, then JavaScript statements are like full sen‐ tences. Statements are the topic of `Chapter 5` . Roughly, an expression is something that computes a value but doesn’t do anything: it doesn’t alter the program state in any way. Statements, on the other hand, don’t have a value, but they do alter the state. You’ve seen variable declarations and assignment statements above. The other broad category of statement is control structures, such as conditionals and loops. You’ll see examples below, after we cover functions.

A function is a named and parameterized block of JavaScript code that you define once, and can then invoke over and over again. Functions aren’t covered formally until `Chapter 8` , but like objects and arrays, you’ll see them many times before you get to that chapter. Here are some simple examples:

``` js
// Functions are parameterized blocks of JavaScript code that we can invoke.
function plus1(x) { // Define a function named "plus1" with parameter "x"
    return x + 1; // Return a value one larger than the value passed in
} // Functions are enclosed in curly braces

plus1(y) // => 4: y is 3, so this invocation returns 3+1

let square = function(x) { // Functions are values and can be assigned to vars
    return x * x; // Compute the function's value
}; // Semicolon marks the end of the assignment.
square(plus1(y)) // => 16: invoke two functions in one expression
```

In ES6 and later, there is a shorthand syntax for defining functions. This concise syn‐ tax uses => to separate the argument list from the function body, so functions defined this way are known as arrow functions. Arrow functions are most commonly used when you want to pass an unnamed function as an argument to another function. The preceding code looks like this when rewritten to use arrow functions:

``` js
const plus1 = x => x + 1; // The input x maps to the output x + 1 
const square = x => x * x; // The input x maps to the output x * x
plus1(y) // => 4: function invocation is the same 
square(plus1(y)) // => 16
```

When we use functions with objects, we get methods:

``` js
// When functions are assigned to the properties of an object, we call
// them "methods."  All JavaScript objects (including arrays) have methods:
let a = []; // Create an empty array
a.push(1, 2, 3); // The push() method adds elements to an array
a.reverse(); // Another method: reverse the order of elements

// We can define our own methods, too. The "this" keyword refers to the object 
// on which the method is defined: in this case, the points array from earlier. 

points.dist = function() { // Define a method to compute distance between points
    let p1 = this[0]; // First element of array we're invoked on
    let p2 = this[1]; // Second element of the "this" object
    let a = p2.x - p1.x; // Difference in x coordinates
    let b = p2.y - p1.y; // Difference in y coordinates
    return Math.sqrt(a * a + // The Pythagorean theorem
        b * b); // Math.sqrt() computes the square root 
};
points.dist() // => Math.sqrt(2): distance between our 2 points
```

Now, as promised, here are some functions whose bodies demonstrate common Java‐ Script control structure statements:

``` js
// JavaScript statements include conditionals and loops using the syntax
// of C, C++, Java, and other languages.
function abs(x) { // A function to compute the absolute value.
    if (x >= 0) { // The if statement...
        return x; // executes this code if the comparison is true.
    } // This is the end of the if clause.
    else { // The optional else clause executes its code if
        return -x; // the comparison is false.
    } // Curly braces optional when 1 statement per clause.
} // Note return statements nested inside if/else.

abs(-10) === abs(10) // => true

function sum(array) { // Compute the sum of the elements of an array
    let sum = 0; // Start with an initial sum of 0.
    for (let x of array) { // Loop over array, assigning each element to x.
        sum += x; // Add the element value to the sum.
    } // This is the end of the loop.
    return sum; // Return the sum.
}
sum(primes) // => 28: sum of the first 5 primes 2+3+5+7+11

function factorial(n) { // A function to compute factorials
    let product = 1; // Start with a product of 1
    while (n > 1) { // Repeat statements in {} while expr in () is true
        product *= n; // Shortcut for product = product * n;
        n--; // Shortcut for n = n - 1
    } // End of loop
    return product; // Return the product
}
factorial(4) // => 24: 1*4*3*2

function factorial2(n) { // Another version using a different loop
    let i, product = 1; // Start with 1
    for (i = 2; i <= n; i++) // Automatically increment i from 2 up to n
        product *= i; // Do this each time. {} not needed for 1-line loops
    return product; // Return the factorial
}
factorial2(5) // => 120: 1*2*3*4*5
```

JavaScript supports an object-oriented programming style, but it is significantly dif‐ ferent than “classical” object-oriented programming languages. `Chapter 9` covers object-oriented programming in JavaScript in detail, with lots of examples. Here is a very simple example that demonstrates how to define a JavaScript class to represent 2D geometric points. Objects that are instances of this class have a single method, named distance(), that computes the distance of the point from the origin:

```js   
class Point {               // By convention, class names are capitalized.

    constructor(x, y) {     // Constructor function to initialize new instances.
        this.x = x;         // This keyword is the new object being initialized.
        this.y = y;         // Store function arguments as object properties.
    }                       // No return is necessary in constructor functions.
    distance() {            // Method to compute distance from origin to point.
        return Math.sqrt(   // Return the square root of x2 + y2.
        this.x * this.x +   // this refers to the Point object on which
        this.y * this.y     // the distance method is invoked. );
    } 

}

// Use the Point() constructor function with "new" to create Point objects 
let p = new Point(1, 1); // The geometric point (1, 1).

// Now use a method of the Point object p
p.distance()                // => Math. SQRT2

``` 
This introductory tour of JavaScript’s fundamental syntax and capabilities ends here, but the book continues with self-contained chapters that cover additional features of the language:

_Chapter 10, Modules_

Shows how JavaScript code in one file or script can use JavaScript functions and classes defined in other files or scripts.

_Chapter 11, The JavaScript Standard Library_

Covers the built-in functions and classes that are available to all JavaScript pro‐ grams. This includes important data stuctures like maps and sets, a regular

expression class for textual pattern matching, functions for serializing JavaScript data structures, and much more.

_Chapter 12, Iterators and Generators_

Explains how the for/of loop works and how you can make your own classes iterable with for/of. It also covers generator functions and the yield statement.

_Chapter 13, Asynchronous JavaScript_

This chapter is an in-depth exploration of asynchronous programming in Java‐ Script, covering callbacks and events, Promise-based APIs, and the async and await keywords. Although the core JavaScript language is not asynchronous, asynchronous APIs are the default in both web browsers and Node, and this chapter explains the techniques for working with those APIs.

_Chapter 14, Metaprogramming_

Introduces a number of advanced features of JavaScript that may be of interest to programmers writing libraries of code for other JavaScript programmers to use.

_Chapter 15, JavaScript in Web Browsers_

Introduces the web browser host environment, explains how web browsers exe‐ cute JavaScript code, and covers the most important of the many APIs defined by web browsers. This is by far the longest chapter in the book.

_Chapter 16, Server-Side JavaScript with Node_

Introduces the Node host environment, covering the fundamental programming model and the data structures and APIs that are most important to understand.

_Chapter 17, JavaScript Tools and Extensions_

Covers tools and language extensions that are worth knowing about because they are widely used and may make you a more productive programmer.

## 1.4 Example: Character Frequency Histograms

This chapter concludes with a short but nontrivial JavaScript program. `Example 1-1` is a Node program that reads text from standard input, computes a character frequency histogram from that text, and then prints out the histogram. You could invoke the program like this to analyze the character frequency of its own source code:

* $ node charfreq.js < charfreq.js
* T: ########### 11.22%
* E: ########## 10.15%
* R: ####### 6.68%
* S: ###### 6.44%
* A: ###### 6.16%
* N: ###### 5.81%
* O: ##### 5.45%
* I: ##### 4.54%
* H: #### 4.07%
* C: ### 3.36%
* L: ### 3.20%
* U: ### 3.08%
* /: ### 2.88%

This example uses a number of advanced JavaScript features and is intended to demonstrate what real-world JavaScript programs can look like. You should not expect to understand all of the code yet, but be assured that all of it will be explained in the chapters that follow.

_Example 1-1. Computing character frequency histograms with JavaScript_

```js
/**
 * This Node program reads text from standard input, computes the frequency
 * of each letter in that text, and displays a histogram of the most
 * frequently used characters. It requires Node 12 or higher to run.
 *
 * In a Unix-type environment you can invoke the program like this:
 *    node charfreq.js < corpus.txt
 */

// This class extends Map so that the get() method returns the specified 
// value instead of null when the key is not in the map
class DefaultMap extends Map {
    constructor(defaultValue) {
        super();                            // Invoke superclass constructor 
        this.defaultValue = defaultValue;   // Remember the default value
    }
    get(key) {
        if (this.has(key)) {                // If the key is already in the map
            return super.get(key);          // return its value from superclass.
        }
        else {
            return this.defaultValue;       // Otherwise return the default value      
        }
    }
}

// This class computes and displays letter frequency histograms
class Histogram { 
    constructor() {
        this.letterCounts = new DefaultMap(0); // Map from letters to counts
        this.totalLetters = 0;                  // How many letters in all 
    }

    // This function updates the histogram with the letters of text.
    add(text) {
        // Remove whitespace from the text, and convert to upper case 
        text = text.replace(/\s/g, "").toUpperCase();

        // Now loop through the characters of the text
        for(let character of text) {
            let count = this.letterCounts.get(character);   // Get old count 
            this.letterCounts.set(character, count+1);      // Increment it 
            this.totalLetters++;
        }
    }
    
    // Convert the histogram to a string that displays an ASCII graphic
    toString() {
        // Convert the Map to an array of [key,value] arrays 
        let entries = [...this.letterCounts];

        // Sort the array by count, then alphabetically
        entries.sort((a,b) => {                 // A function to define sort order.
            if (a[1] === b[1]) {                // If the counts are the same 
                return a[0] < b[0] ? -1 : 1;    // sort alphabetically.
            }else{                              // If the counts differ
                return b[1] - a[1];             // sort by largest count.
            }
        });

        // Convert the counts to percentages
        for(let entry of entries) {
            entry[1] = entry[1] / this.totalLetters*100;
        }

        // Drop any entries less than 1%
        entries = entries.filter(entry => entry[1] >= 1);
        
        // Now convert each entry to a line of text
        let lines = entries.map(
            ([l,n]) => `${l}: ${"#".repeat(Math.round(n))} ${n.toFixed(2)}%`
        );

        // And return the concatenated lines, separated by newline characters.
        return lines.join("\n"); 
    }
}

// This async (Promise-returning) function creates a Histogram object,
// asynchronously reads chunks of text from standard input, and adds those chunks to // the histogram. When it reaches the end of the stream, it returns this histogram 

async function histogramFromStdin() {
    process.stdin.setEncoding("utf-8"); // Read Unicode strings, not bytes 
    let histogram = new Histogram();
    for await (let chunk of process.stdin) {
        histogram.add(chunk);
    }
    return histogram; 
}

// This one final line of code is the main body of the program.
// It makes a Histogram object from standard input, then prints the histogram.
histogramFromStdin().then(histogram => { console.log(histogram.toString()); });
```

# 1.5 Summary

This book explains JavaScript from the bottom up. This means that we start with low- level details like comments, identifiers, variables, and types; then build to expressions, statements, objects, and functions; and then cover high-level language abstractions like classes and modules. I take the word definitive in the title of this book seriously, and the coming chapters explain the language at a level of detail that may feel off- putting at first. True mastery of JavaScript requires an understanding of the details, however, and I hope that you will make time to read this book cover to cover. But please don’t feel that you need to do that on your first reading. If you find yourself feeling bogged down in a section, simply skip to the next. You can come back and master the details once you have a working knowledge of the language as a whole.
